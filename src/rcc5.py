#!/usr/bin/env python3
# ≥ ≤ ≳ ≲ ≂

import sys

# Actually this is RCC-29 or something...

# intended for use with: from rcc5 import *

# RCC-5 relationship WITHIN hierarchy
# Use logical | for disjunction, & for conjunction

rcc5_symbols = {}
rcc5_eulerxs = {}
rcc5_relationships = {}
def def_rcc5_symbol(n, name, exname=None):
  if exname==None: exname = name
  rcc5_eulerxs[n] = exname
  rcc5_symbols[n] = name
  rcc5_relationships[name] = n
  rcc5_relationships[exname] = n
  return n

LT = def_rcc5_symbol(1 << 0, '<')
GT = def_rcc5_symbol(1 << 1, '>')
EQ = def_rcc5_symbol(1 << 2, '=') # congruent
DISJOINT = def_rcc5_symbol(1 << 3, '!')
OVERLAP = def_rcc5_symbol(1 << 4, '><')
rcc5_relationships['*'] = OVERLAP # for concise composition table

# Disjunctions
NEQ = def_rcc5_symbol(LT|GT|OVERLAP|DISJOINT, '!=')     # ≠, not congruent
LE = def_rcc5_symbol(LT|EQ, '<=')       # ≤, synonym
GE = def_rcc5_symbol(GT|EQ, '>=')       # ≥, accepted
COMPARABLE = def_rcc5_symbol(LT|GT, '<>')
INTERSECT = def_rcc5_symbol(LT|GT|EQ|OVERLAP, 'not!')  # ∩
rcc5_relationships['∩'] = INTERSECT
# bottom
NOINFO = def_rcc5_symbol(LT|GT|EQ|OVERLAP|DISJOINT, '?')
# top (unicode ⋕ is 'equal and parallel to')
INCONSISTENT = def_rcc5_symbol(0, '⋕', '{}')

HAS_PARENT = LT
SYNONYM = LE
MYNONYS = GE
NEQ = def_rcc5_symbol(LT|GT|OVERLAP|DISJOINT, 'not=')

PERI = def_rcc5_symbol(LT|DISJOINT, '<!')
IREP = def_rcc5_symbol(GT|DISJOINT, '>!')

def reverse_relationship(ship):
  l = (ship & LT)
  g = (ship & GT)
  strip = (ship - (l|g))
  if l > 0: strip |= GT
  if g > 0: strip |= LT
  return strip

# Take apart a conjunction into its parts

def explode_rcc5(ship):
  for r in (LT, GT, EQ, DISJOINT, OVERLAP):
    if ship & r > 0:
      yield r

# If we come across an int relation coding, there had better be such a relation

def rcc5_symbol(ship):
  sym = rcc5_symbols.get(ship)
  if sym: return sym
  else:
    s = [rcc5_symbol(r) for r in explode_rcc5(ship)]
    return "{%s}" % " ".join(s)

def rcc5_eulerx(ship):
  components = tuple(explode_rcc5(ship))
  if len(components) == 1:
    return rcc5_symbols[ship]
  else:
    s = [rcc5_symbols[r] for r in components]
    return "{%s}" % " ".join(s)

def rcc5_relationship(name):
  if name.startswith('{'):
    ship = 0
    for name in name[1:-1].split(' '):
      ship |= rcc5_relationship(name)
    return ship
  return rcc5_relationships[name]

# The table only goes from pairs of single RCC-5 relationships to a
# the set of the possible resulting RCC-5 relationships.  If the
# inputs are themselves sets, we just iterate in order to get all
# possible results for all possible inputs.

def compose_relationships(r, s):
  ship = 0
  for r1 in explode_rcc5(r):
    for s1 in explode_rcc5(s):
      ship |= rcc5_composition_table[(r1, s1)]
  return ship

# -----------------------------------------------------------------------------
# Composing RCC5 relationships

# This table was automatically generated by the code that follows it.

symbolic_rcc5_composition_table = {
  ('=', '='): '=',
  ('=', '<'): '<',
  ('=', '>'): '>',
  ('=', '!'): '!',
  ('=', '><'): '><',
  ('<', '='): '<',
  ('<', '<'): '<',
  ('<', '>'): '?',
  ('<', '!'): '!',
  ('<', '><'): '{< ! ><}',
  ('>', '='): '>',
  ('>', '<'): 'not!',
  ('>', '>'): '>',
  ('>', '!'): '{> ! ><}',
  ('>', '><'): '{> ><}',
  ('!', '='): '!',
  ('!', '<'): '{< ! ><}',
  ('!', '>'): '!',
  ('!', '!'): '?',
  ('!', '><'): '{< ! ><}',
  ('><', '='): '><',
  ('><', '<'): '{< ><}',
  ('><', '>'): '{> ! ><}',
  ('><', '!'): '{> ! ><}',
  ('><', '><'): '?',
  }

rcc5_composition_table = \
  {(rcc5_relationship(r),rcc5_relationship(s)): rcc5_relationship(symbolic_rcc5_composition_table[(r,s)])
   for (r,s) in symbolic_rcc5_composition_table.keys()}

"""
Calculating the table given above by brute force, using truth tables:

A model is an assignment of the names A, B, C to nonempty subsets of a 
set of 7 individuals.

There are 127 possible A sets, 127 possible B sets, 127 possible C sets.
So, there are (expt 127 3) = 2048383 models.

For each model,
  classify it according to A ? B (5 possibilities),
  classify it according to B ? C (5 possibilities),
then
  classify it according to A ? C (5 possibilities),
For each ?1 ?2, prepare a list of which ?3s can result.
"""

def generate_rcc5_composition_table():

  def generate_sets():
    return range(1, 128)

  def generate_models():
    return ((i, j, k)
            for i in generate_sets()
            for j in generate_sets()
            for k in generate_sets())

  def compare(S, T):
    if S == T: return EQ
    elif S & T == S: return LT
    elif S & T == T: return GT
    elif S & T == 0: return DISJOINT
    else: return OVERLAP

  def doit():
    results = {}
    for (A, B, C) in generate_models():
      r1 = compare(A, B)
      r2 = compare(B, C)
      r3 = compare(A, C)
      key = (r1, r2)              # maps to set of r3
      if key in results:
        results[key] = results[key] | r3
      else:
        results[key] = r3   #{(r3)}
    print("symbolic_rcc5_composition_table = {")
    for key in sorted(results.keys()):
      (r1, r2) = key
      display(r1, r2, results[key])
    print("  }")
    testcase = ('<', '!')
    print("print('%s -> %s' % (testcase, rcc5_composition_table[testcase]))")

  def display(r1, r2, r3s):
    print("  ('%s', '%s'): '%s'," %
          (rcc5_symbol(r1),
           rcc5_symbol(r2),
           rcc5_symbol(r3s)
           #"".join(map(rcc5_character, explode_rcc5(r3s)))
          ))
  doit()

if __name__ == '__main__':
  #print(rcc5_symbol(compose_relationships(LT, LT)))
  generate_rcc5_composition_table()
