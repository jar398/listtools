#!/usr/bin/env python3

import sys, csv
from typing import NamedTuple, Any

import property as prop
import checklist

from util import log, MISSING
from checklist import *
from coproduct import *

# -----------------------------------------------------------------------------
# Sum / coproduct / merged checklist / theory workspace
# Could be either just the matches (not a checklist), or the matches
# plus overrides (synthetic checklist)

# Returns B side

REUSE_KEYS = True

def make_workspace(A, B, meta=None):
  Q = prop.make_context()       # allows overriding A and/or B
  (get_inject, set_inject) = prop.get_set(inject_prop, context=Q)

  register = prop.get_registrar(primary_key_prop, Q)
  pk_counter = [0]
  missing = False

  def ensure_injected(x):
    z = get_inject(x, None)
    if not z:
      z = prop.clone(x)         # sets canonical, scientific, rank, type etc
      set_inject(x, z)          # contextual
      set_outject(z, x)
      set_source(z, AB)
      if get_superior(z, None) != None:
        set_superior(z, None)
      if get_children(z, None) != None:
        set_children(z, None)
      if get_synonyms(z, None) != None:
        set_synonyms(z, None)

      have_key = get_primary_key(z)
      # and not get_record(primary_key_prop, None)
      key = "%s!%s" % (get_source_name(x), have_key)
      set_primary_key(z, key)
      register(z)
    return z

  def _in_left(x):
    assert get_source(x) == A, get_source_name(x)
    return ensure_injected(x)
  def _in_right(y):
    assert get_source(y) == B, get_source_name(y)
    return ensure_injected(y)
  def _case(z, when_left, when_right):
    w = get_outject(z, None)
    assert w
    if get_source(w) == A:
      return when_left(w)
    else:
      assert get_source(w) == B
      return when_right(w)
  AB = Coproduct(_in_left, _in_right, _case)
  AB.context = Q

  AB.meta = meta

  AB.A = A           # need ??
  AB.B = B

  # Force local copies of all source records
  for y in all_records(B): AB.in_right(y) # not including top
  for x in all_records(A): AB.in_left(x)  # not including top
  # AB.top is not set at this point.  Needs to be determined independently
  #log("# taxonID counter: %s" % pk_counter[0])

  return AB

# NOT INVOKED

def some_stuff_to_do(AB):
  atop = AB.in_left(AB.A.top)
  btop = AB.in_right(AB.B.top)

  # cf. propose_equation
  set_superior(atop, relation(EQ, btop, "top"))
  set_equated(btop, relation(EQ, atop, "top"))
  AB.top = btop

  AB.indexed = False

# Is given synonym usage a senior synonym of its accepted usage?
# In the case of splitting, we expect the synonym to be a senior
# synonym of the item.

# We could also look to see if taxonomicStatus is 'senior synonym'.

# Hmm, if there's exactly one senior synonym, we should remember it as
# being the 'split from' taxon.

def is_senior(synonym_item, accepted_item):
  syn_year = get_year(synonym_item, None)  # the synonym
  acc_year = get_year(accepted_item, None)
  if syn_year and acc_year:
    # Older name (senior) has priority over newer (junior)
    # but if junior is accepted we don't care about the senior.
    if syn_year <= acc_year:
      # synonym is older than accepted, so syn > acc.  Shouldn't
      # happen.  (these are generated by MDD)
      print("# Flushing senior synonym '%s' of '%s'" %
            (get_scientific(synonym_item),
             get_scientific(accepted_item)))
      return True
    else:
      # synonym is newer than accepted, so syn < acc.  Junior.
      #  (split)
      return False
  else:
    return False

# -----------------------------------------------------------------------------

# Output with additional columns needed by report.py

def workspace_preorder_rows(AB, props=None):
  return checklist.preorder_rows(AB, props or usual_workspace_props)

usual_workspace_props = usual_props + \
    (prop.declare_property("equated_id", getter=recover_equated_key),
     prop.declare_property("equated_note", getter=recover_equated_note),
     prop.declare_property("match_id", getter=recover_match_key),
     prop.declare_property("basis_of_match", getter=recover_basis_of_match))

# -----------------------------------------------------------------------------
# Little baby tests

import newick

def workspace_from_newicks(m, n):
  B = rows_to_checklist(newick.parse_newick(n),
                        {"name": "B"})  # meta
  A = rows_to_checklist(newick.parse_newick(m),
                        {"name": "A"})  # meta
  AB = make_workspace(A, B, {"name": "AB"})
  if False:
    for record in all_records(AB): # No merge
      if record != AB.top:
        set_superior(record, relation(SYNONYM, AB.top, "testing"))
  return AB

def show_workspace(AB, props=None):
  props = props or usual_workspace_props
  writer = csv.writer(sys.stdout)
  rows = list(workspace_preorder_rows(AB, props))
  for row in rows:
    writer.writerow(row)
  print(' = ' + newick.compose_newick(rows))

if __name__ == '__main__':
  def testit(m, n):
    AB = workspace_from_newicks(m, n)
    show_workspace(AB)
  testit("(c,d)a", "(c,e)b")
