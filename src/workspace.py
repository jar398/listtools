#!/usr/bin/env python3

import sys, csv
from typing import NamedTuple, Any

import property as prop
import checklist

from util import log
from checklist import *
from coproduct import *

# -----------------------------------------------------------------------------
# Sum / coproduct / merged checklist / theory workspace
# Could be either just the matches (not a checklist), or the matches
# plus overrides (synthetic checklist)

# Returns B side

REUSE_KEYS = True

def make_workspace(A, B, meta=None):
  Q = prop.make_context()       # allows overriding A and/or B
  (get_inject, set_inject) = prop.get_set(inject_prop, context=Q)

  register = prop.get_registrar(primary_key_prop, Q)
  pk_counter = [0]
  missing = False

  def ensure_injected(x):
    z = get_inject(x, None)
    if not z:
      z = prop.clone(x)
      set_inject(x, z)          # contextual
      set_outject(z, x)
      # Every node starts out being a child of ‚ä§
      set_superior(z, None)
      set_children(z, None)   # Force local
      set_synonyms(z, None)   # Force local
      set_source(z, AB)
      have_key = get_primary_key(z)
      if not have_key or not REUSE_KEYS:
        pk_counter[0] += 1
        set_primary_key(z, str(pk_counter[0]))
      elif not ('!' in have_key):
        key = "%s!%s" % (get_source_name(x), have_key)
        set_primary_key(z, key)
      register(z)
    return z

  def _in_left(x):
    assert get_source(x) == A
    assert not is_top(x)
    return ensure_injected(x)
  def _in_right(y):
    assert get_source(y) == B
    return ensure_injected(y)
  def _case(z, when_left, when_right):
    w = get_outject(z)
    if get_source(w) == A:
      return when_left(w)
    else:
      assert get_source(w) == B
      return when_right(w)
  AB = Coproduct(_in_left, _in_right, _case)
  AB.context = Q
  AB.top = AB.in_right(B.top)
  AB.topship = Related(LT, AB.top, "uninitialized")
  AB.indexed = False
  AB.meta = meta

  AB.A = A           # need ??
  AB.B = B

  # Force local copies of all source records
  for y in all_records(B): AB.in_right(y) # not including top
  for x in all_records(A): AB.in_left(x)  # not including top
  log("# taxonID counter: %s" % pk_counter[0])

  return AB

# -----------------------------------------------------------------------------
# Load/dump a set of provisional matches (could be either record match
# or taxonomic matches... but basically, record matches)

# Fields of match records <A (matched), relation, B (taxon), remark>
get_match_relation = prop.getter(prop.get_property("match_relation"))
get_matched_key = prop.getter(prop.get_property("matched_id"))
get_match_note = prop.getter(prop.get_property("match_note"))

def load_equivalences(row_iterator, AB):

  header = next(iterator)
  plan = prop.make_plan_from_header(header)
  match_count = 0
  miss_count = 0
  for row in row_iterator:
    # [matchID rel taxonID remark]
    match = prop.construct(plan, row)

    # The columns of the csv file
    xkey = get_matched_key(match, None)
    relation = get_match_relation(match)
    ykey = get_primary_key(match)
    remark = get_match_note(match)

    x = y = None
    if xkey:
      x_in_A = look_up_record(AB.A, xkey)
      if x_in_A:
        x = AB.in_left(x_in_A)
        AB.set_match_note(x, remark)
    if ykey:
      y_in_B = look_up_record(AB.B, ykey)
      if y_in_B:
        y = AB.in_right(y_in_B) 
        AB.set_match_note(y, remark)
    if x and y and relation == '=':
      set_match(x, y)
      set_match(y, x)
      match_count += 1
    elif x or y:
      unmatch += 1
  log("# %s matches, %s misses" % (match_count, miss_count))

"""
TBD: filter out seniors
  seniors = 0
      # Filter out senior synonyms here
      if is_senior(item, accepted_item):
        seniors += 1
      else:
  if seniors > 0:     # Maybe interesting
    print("-- Suppressed %s senior synonyms" % seniors,
          file=sys.stderr)

"""

# Is given synonym usage a senior synonym of its accepted usage?
# In the case of splitting, we expect the synonym to be a senior
# synonym of the item.

# We could also look to see if taxonomicStatus is 'senior synonym'.

# Hmm, if there's exactly one senior synonym, we should remember it as
# being the 'split from' taxon.

def is_senior(synonym_item, accepted_item):
  syn_year = get_year(synonym_item, None)  # the synonym
  acc_year = get_year(accepted_item, None)
  if syn_year and acc_year:
    # Older name (senior) has priority over newer (junior)
    # but if junior is accepted we don't care about the senior.
    if syn_year <= acc_year:
      # synonym is older than accepted, so syn > acc.  Shouldn't
      # happen.  (these are generated by MDD)
      print("# Flushing senior synonym '%s' of '%s'" %
            (get_scientific(synonym_item),
             get_scientific(accepted_item)))
      return True
    else:
      # synonym is newer than accepted, so syn < acc.  Junior.
      #  (split)
      return False
  else:
    return False

# -----------------------------------------------------------------------------

if __name__ == '__main__':
  import newick

  def testit(m, n):
    # Always load B first
    B = rows_to_checklist(newick.parse_newick(n),
                          {"name": "B"})  # meta
    A = rows_to_checklist(newick.parse_newick(m),
                          {"name": "A"})  # meta
    AB = make_workspace(A, B, {"name": "AB"})
    assert A.top
    ensure_inferiors_indexed(AB)
    writer = csv.writer(sys.stdout)
    rows = list(preorder(AB))
    for row in rows:
      writer.writerow(row)
    print(' = ' + newick.compose_newick(rows))

  testit("(c,d)a", "(c,e)b")
