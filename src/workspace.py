#!/usr/bin/env python3

import sys, csv
from typing import NamedTuple, Any

import property as prop
import checklist
import match_records

from util import log, MISSING
from checklist import *
from coproduct import *

def ingest_workspace(A_gen, A_name, B_gen, B_name, matches_gen):
  A = rows_to_checklist(A_gen, {'tag': A_name or "A"})  # meta
  B = rows_to_checklist(B_gen, {'tag': B_name or "B"})  # meta
  AB = make_workspace(A, B, {'tag': "AB"})
  if not matches_gen:
    matches_gen = match_records.match_records(checklist_to_rows(AB.A),
                                              checklist_to_rows(AB.B))
  mm = list(matches_gen)
  log("# ingest: %s matches" % len(mm))
  checklist.load_matches(iter(mm), AB)  # matches_gen
  return AB

# -----------------------------------------------------------------------------
# Sum / coproduct / merged checklist / theory workspace
# Could be either just the matches (not a checklist), or the matches
# plus overrides (synthetic checklist)

# Returns B side

REUSE_KEYS = True

def make_workspace(A, B, meta=None):
  Q = prop.make_context()       # allows overriding A and/or B
  (get_inject, set_inject) = prop.get_set(inject_prop, context=Q)

  register = prop.get_registrar(primary_key_prop, Q)
  pk_counter = [0]
  missing = False

  def ensure_injected(x):
    z = get_inject(x, None)
    if not z:
      z = prop.clone(x)         # sets canonical, scientific, rank, type etc
      set_inject(x, z)          # contextual
      set_outject(z, x)
      set_source(z, AB)
      if get_superior(z, None) != None:
        set_superior(z, None)
      if get_children(z, None) != None:
        set_children(z, None)
      if get_synonyms(z, None) != None:
        set_synonyms(z, None)

      have_key = get_primary_key(z)
      # and not get_record(primary_key_prop, None)
      key = "%s!%s" % (get_source_tag(x), have_key)
      set_primary_key(z, key)
      register(z)
    return z

  def _in_left(x):
    assert get_source(x) == A, ("expected left", get_source_tag(x))
    return ensure_injected(x)
  def _in_right(y):
    assert get_source(y) == B, ("expected right", get_source_tag(y))
    return ensure_injected(y)
  def _case(z, when_left, when_right):
    w = get_outject(z, None)
    assert w, blurb(z)
    if get_source(w) == A:
      return when_left(w)
    else:
      assert get_source(w) == B
      return when_right(w)
  AB = Coproduct(_in_left, _in_right, _case)
  AB.context = Q

  AB.meta = meta

  AB.A = A           # need ??
  AB.B = B

  # Force local copies of all source records
  for y in all_records(B): AB.in_right(y) # not including top
  for x in all_records(A): AB.in_left(x)  # not including top
  # AB.top is not set at this point.  Needs to be determined independently
  #log("# taxonID counter: %s" % pk_counter[0])

  return AB

# Is given synonym usage a senior synonym of its accepted usage?
# In the case of splitting, we expect the synonym to be a senior
# synonym of the item.

# We could also look to see if taxonomicStatus is 'senior synonym'.

# Hmm, if there's exactly one senior synonym, we should remember it as
# being the 'split from' taxon.

def is_senior(synonym_item, accepted_item):
  syn_year = get_year(synonym_item, None)  # the synonym
  acc_year = get_year(accepted_item, None)
  if syn_year and acc_year:
    # Older name (senior) has priority over newer (junior)
    # but if junior is accepted we don't care about the senior.
    if syn_year <= acc_year:
      # synonym is older than accepted, so syn > acc.  Shouldn't
      # happen.  (these are generated by MDD)
      print("# Flushing senior synonym '%s' of '%s'" %
            (get_scientific(synonym_item),
             get_scientific(accepted_item)))
      return True
    else:
      # synonym is newer than accepted, so syn < acc.  Junior.
      #  (split)
      return False
  else:
    return False

# -----------------------------------------------------------------------------

# Utilities for use in other modules

def isinA(AB, z):
  return AB.case(z, lambda x: True, lambda x: False)

def isinB(AB, z):
  return AB.case(z, lambda x: False, lambda x: True)

def separated(x, y):
  AB = get_source(x)
  return isinA(AB, x) != isinA(AB, y)

# Returns <p, syn> where p in AB is superior in A (or B) of v,
#  and syn is true iff p is a synonym

def local_sup(AB, v):
  assert v, 'local_sup'
  assert get_outject(v)
  loc = get_superior(get_outject(v), None)
  if not loc:
    return None
  if isinA(AB, v):
    return relation(loc.relationship, AB.in_left(loc.record),
                    note=loc.note, span=loc.span)
  else:
    return relation(loc.relationship, AB.in_right(loc.record),
                    note=loc.note, span=loc.span)

def local_accepted(AB, v):
  y = get_accepted(get_outject(v))
  if isinA(AB, v):
    return AB.in_left(y)
  else:
    return AB.in_right(y)

def swap(AB):
  BA = AB.swap()
  BA.A = AB.B
  BA.B = AB.A
  return BA

# -----------------------------------------------------------------------------

# Output with additional columns needed by report.py

def workspace_preorder_rows(AB, props=None):
  return checklist.preorder_rows(AB, props or usual_workspace_props)

usual_workspace_props = usual_props + \
    (prop.declare_property("equated_id", getter=recover_equated_key),
     prop.declare_property("equated_note", getter=recover_equated_note),
     prop.declare_property("match_id", getter=recover_match_key),
     prop.declare_property("basis_of_match", getter=recover_basis_of_match))

# -----------------------------------------------------------------------------
# Little baby tests

import newick

def workspace_from_newicks(m, n):
  B = rows_to_checklist(newick.parse_newick(n),
                        {'tag': "B"})  # meta
  A = rows_to_checklist(newick.parse_newick(m),
                        {'tag': "A"})  # meta
  AB = make_workspace(A, B, {'tag': "AB"})
  if False:
    for record in all_records(AB): # No merge
      if record != AB.top:
        set_superior(record, relation(SYNONYM, AB.top, note="testing"))
  return AB

def show_workspace(AB, props=None):
  props = props or usual_workspace_props
  writer = csv.writer(sys.stdout)
  rows = list(workspace_preorder_rows(AB, props))
  for row in rows:
    writer.writerow(row)
  print(' = ' + newick.compose_newick(rows))

if __name__ == '__main__':
  def testit(m, n):
    AB = workspace_from_newicks(m, n)
    show_workspace(AB)
  testit("(c,d)a", "(c,e)b")
