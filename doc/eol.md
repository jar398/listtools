
## Configuration for EOL

For EOL, the list tools are intended to be used in conjunction with
`plotter`, which provides access to file repositories such as
`content.eol.org` and other sources of EOL information.

Configure `plotter` according to its documentation.  Then, assuming
the `plotter` repository is cloned in directory `../plotter`, do the
following in your `listtools` working directory:

    ln -sfT ../plotter/config config

Depending on the location of `plotter` and the directory where you're
working, adjust the above command, and also update `Makefile` where it
mentions `plotter`.

## Record-based delta/diff/patch feature

(These programs are inherited from a previous round of development and
may not work any more!  Note that they operate only on records,
insensitive to hierarchy.)

### delta

`delta` compares two files (call them A and B), matching rows of one
to rows of the other, and generating a "delta" (call it B-A) which
describes the differences between A and B.  A delta is an annotated
report listing all unmatched and changed rows, not including exact row
matches.

    src/delta.py <a.csv --target b.csv \
                        --matches m.csv \
                        --pk y \
                        --index x,y,z \
                        --managed z,y,d,e,f

`--matches` names a file that was generated by `match_records` (or
another tool generating the same kind of file).  If it's omitted then
`match_records` is invoked implicitly.

`--pk` specifies the primary key column for both inputs.

Each row of the delta comes from A only, from B only, or from matched
rows in A and B.  Because of the use of deltas in patching, these
three types of row are given labels `remove`, `add`, and `update` in
the `mode` column of the delta.  The primary key in the delta is taken
from A in the case of `remove` and `update` records.  The primary key
from the B file is given in `new_pk` of the delta.

The output contains only the managed columns (`--managed`), and matched
rows are considered updated only if one of the managed columns
differs.

The matches are done on only a row-by-row basis and are not sensitive
to hierarchy or other sources of meaning.  Hierarchy and
synonym-to-accepted links are treated the same as any other field and
do not require identical contents, meaning that the overall comparison
is not truly sensitive to hierarchy.  Rows may be matched even
when consideration of hierarchy would require them to be interpreted
as distinct taxa.  For hierarchy sensitive comparison see `align`, below.

### apply

Applies a sorted delta, B-A, to a sorted file A (which typically would be
the A file from which the delta was generated), generating a file B′.
B′ will be projection of B to the given 'managed' columns, with
perhaps the rows in a different order.

    src/apply.py --delta ba.delta --pk taxonID \
                 < a.csv > b2.csv

The delta would probably be produced by the delta tool.  It should
have columns `mode` and `new_pk` (see above).

### scatter

Given a delta, generate a directory containing one file for each of
the three kinds of record in the delta (add, udpate, remove).

    src/scatter.py <delta.csv --dest delta

writes `delta/add.csv`, `delta/update.csv`, `delta/remove.csv`.  These
can be fed to appropriate database commands to incrementally update a
database to a new version of a table (intended for EOL mainly).

### hierarchy

This is specific to EOL.  It applies a taxon id (`taxonID`) to 
'page id' mapping to a file full of records to generate a file
with one record per page, giving the parent of each taxon.

This looks up the EOL 'node ids' in a dynamic hierarchy file to obtain
the corresponding 'page ids'.  A draft DH will contain many taxa that
didn't have page ids at the time the draft was produced, but page ids
are assigned when the draft is 'harvested' and can be found by looking
at the database.  that is what this tool does, I believe.

The resulting taxon list can be subjected to `delta` and `scatter` to
incrementally update an in-database hierarchy, etc.

Columns expected: `taxonID`, `parentNameUsageID`,
`acceptedNameUsageID`, `taxonomicStatus`

### idmap

I don't know how this differs from `hierarchy`.
